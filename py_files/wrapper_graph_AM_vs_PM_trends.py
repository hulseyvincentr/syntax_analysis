# wrapper_graph_AM_vs_PM_trends.pyfrom __future__ import annotationsfrom pathlib import Pathfrom typing import Dict, Any, Optional, Sequence, Unionimport jsonimport pandas as pdimport matplotlib.pyplot as plt# External modules from your codebasefrom am_vs_pm_syllable_heatmap import run_am_pm_syllable_heatmapfrom am_pm_transition_entropy_from_decoded import (    analyze_am_pm_transitions_from_decoded,)from graph_AM_vs_PM_phrase_duration_over_days import (    graph_AM_vs_PM_phrase_duration_over_days,)from daily_am_pm_first_order_transitions_movie import (    run_daily_am_pm_first_order_transitions_with_movies,)# ──────────────────────────────────────────────────────────────────────────────# Small helpers# ──────────────────────────────────────────────────────────────────────────────def _ensure_dir(p: Union[str, Path]) -> Path:    p = Path(p)    p.mkdir(parents=True, exist_ok=True)    return pdef _read_treatment_date_str(creation_metadata_json: Union[str, Path]) -> Optional[str]:    """    Return the treatment date string if present in metadata JSON (no parsing).    """    try:        with Path(creation_metadata_json).open("r") as f:            meta = json.load(f)        td = meta.get("treatment_date")        return td if isinstance(td, str) else None    except Exception:        return Nonedef _save_am_pm_entropy_plot(    results_df: pd.DataFrame,    *,    surgery_date_str: Optional[str],    save_path: Union[str, Path],    show: bool = False,) -> Path:    """    Lightweight plotter for AM/PM total transition entropy that SAVES the figure.    (Does not call plt.show() unless show=True.)    """    if results_df.empty:        raise ValueError("No AM/PM entropy values to plot.")    # Prepare series    days_all = sorted(results_df["day"].unique())    am = results_df[results_df["am_pm"] == "AM"].sort_values("day")    pm = results_df[results_df["am_pm"] == "PM"].sort_values("day")    plt.figure(figsize=(22, 7))    plt.scatter(am["day"], am["total_entropy"], marker="o", s=100, edgecolor="black", label="AM (00:00–11:59)")    plt.scatter(pm["day"], pm["total_entropy"], marker="^", s=100, edgecolor="black", label="PM (12:00–23:59)")    # Optional treatment line    if surgery_date_str:        try:            sdt = pd.to_datetime(surgery_date_str).date()            plt.axvline(x=sdt, color="r", linestyle="--", label="Surgery Date")        except Exception:            pass    plt.xticks(ticks=days_all, labels=[pd.to_datetime(d).strftime("%Y-%m-%d") for d in days_all], rotation=90)    plt.title("Total Transition Entropy by Day and Half-Day", fontsize=16)    plt.xlabel("Day", fontsize=14)    plt.ylabel("Total Transition Entropy", fontsize=14)    plt.xticks(fontsize=11)    plt.yticks(fontsize=12)    plt.legend(ncol=3)    plt.tight_layout()    save_path = Path(save_path)    save_path.parent.mkdir(parents=True, exist_ok=True)    plt.savefig(save_path, dpi=300, bbox_inches="tight")    if show:        plt.show()    else:        plt.close()    return save_path# ──────────────────────────────────────────────────────────────────────────────# Main wrapper# ──────────────────────────────────────────────────────────────────────────────def run_am_pm_pipeline(    *,    decoded_database_json: Union[str, Path],    creation_metadata_json: Union[str, Path],    outdir: Union[str, Path],    # Which steps to run (order matters)    steps: Sequence[str] = (        "am_pm_syllable_heatmap",        "am_pm_transition_entropy",        "am_pm_phrase_duration",        "am_pm_transitions_movie",    ),    # Per-step overrides    step_opts: Optional[Dict[str, Dict[str, Any]]] = None,    # Resume: skip outputs that already exist when the step defines concrete files    resume: bool = True,) -> Dict[str, Any]:    """    Batch-run AM vs PM analyses and figures.    Steps (use any subset, in any order):      - "am_pm_syllable_heatmap": AM/PM heatmaps of per-syllable counts      - "am_pm_transition_entropy": AM vs PM total transition entropy across days      - "am_pm_phrase_duration": violin/strip plots per syllable (AM/PM per day)      - "am_pm_transitions_movie": per-day first-order transition matrices (AM, PM, and side-by-side movies)    Returns a dict of step results / file paths.    """    outdir = _ensure_dir(outdir)    opts = step_opts or {}    results: Dict[str, Any] = {}    meta_treatment_date_str = _read_treatment_date_str(creation_metadata_json)    for step in steps:        if step == "am_pm_syllable_heatmap":            # Defaults            save_base = Path(opts.get(step, {}).get("save_path", outdir / "am_pm" / "AMPM_syllable_heatmap.png"))            save_base.parent.mkdir(parents=True, exist_ok=True)            if resume and save_base.with_name(save_base.stem + "_combined" + save_base.suffix).exists():                results[step] = {"skipped": True, "reason": "existing outputs", "base_png": str(save_base)}                continue            res = run_am_pm_syllable_heatmap(                decoded_database_json=decoded_database_json,                creation_metadata_json=creation_metadata_json,                normalize=opts.get(step, {}).get("normalize", "proportion"),                log_scale=opts.get(step, {}).get("log_scale", False),                save_path=save_base,                show=opts.get(step, {}).get("show", False),                cmap=opts.get(step, {}).get("cmap", "Greys"),                verbose=opts.get(step, {}).get("verbose", True),            )            results[step] = {                "animal_id": res.get("animal_id"),                "treatment_date": res.get("treatment_date"),                "combined_png": str(save_base.with_name(save_base.stem + "_combined" + save_base.suffix)) if save_base else None,                "am_png": str(save_base.with_name(save_base.stem + "_AM" + save_base.suffix)) if save_base else None,                "pm_png": str(save_base.with_name(save_base.stem + "_PM" + save_base.suffix)) if save_base else None,            }        elif step == "am_pm_transition_entropy":            # Compute (and we’ll save our own figure)            res = analyze_am_pm_transitions_from_decoded(                decoded_database_json=decoded_database_json,                creation_metadata_json=creation_metadata_json,                only_song_present=opts.get(step, {}).get("only_song_present", False),                compute_durations=opts.get(step, {}).get("compute_durations", False),                surgery_date_override=opts.get(step, {}).get("surgery_date_override", None),                return_syllable_types=False,            )            # res: (organized_df, per_file_df, results_df)            results_df = res[2]            save_path = Path(opts.get(step, {}).get(                "save_path",                outdir / "am_pm" / "AMPM_total_transition_entropy.png",            ))            if not (resume and save_path.exists()):                _save_am_pm_entropy_plot(                    results_df,                    surgery_date_str=opts.get(step, {}).get("surgery_date_override", meta_treatment_date_str),                    save_path=save_path,                    show=opts.get(step, {}).get("show", False),                )            results[step] = {"entropy_csv": None, "entropy_png": str(save_path), "rows": len(results_df)}        elif step == "am_pm_phrase_duration":            save_dir = Path(opts.get(step, {}).get("save_output_to_this_file_path", outdir / "am_pm_phrase_duration"))            save_dir.mkdir(parents=True, exist_ok=True)            if resume and any(save_dir.glob("*_AMPM_phrase_duration_plot.png")):                results[step] = {"skipped": True, "reason": "existing PNGs in output dir", "dir": str(save_dir)}            else:                out = graph_AM_vs_PM_phrase_duration_over_days(                    decoded_database_json=decoded_database_json,                    creation_metadata_json=creation_metadata_json,                    save_output_to_this_file_path=save_dir,                    only_song_present=opts.get(step, {}).get("only_song_present", False),                    y_max_ms=opts.get(step, {}).get("y_max_ms", 25_000),                    point_alpha=opts.get(step, {}).get("point_alpha", 0.7),                    point_size=opts.get(step, {}).get("point_size", 5),                    jitter=opts.get(step, {}).get("jitter", True),                    figsize=opts.get(step, {}).get("figsize", (22, 11)),                    font_size_labels=opts.get(step, {}).get("font_size_labels", 26),                    xtick_fontsize=opts.get(step, {}).get("xtick_fontsize", 8),                    xtick_every_days=opts.get(step, {}).get("xtick_every_days", 1),                    show_plots=opts.get(step, {}).get("show_plots", False),                    syllables_subset=opts.get(step, {}).get("syllables_subset", None),                )                results[step] = {"dir": str(save_dir), "unique_syllables": len(getattr(out, "unique_syllable_labels", []))}        elif step == "am_pm_transitions_movie":            # Directories & filenames            out_dir = Path(opts.get(step, {}).get("output_dir", outdir / "daily_transitions_am_pm"))            out_dir.mkdir(parents=True, exist_ok=True)            save_both = opts.get(step, {}).get("save_movie_both_path", out_dir / "am_pm_per_day.gif")            save_am = opts.get(step, {}).get("save_movie_am_path", out_dir / "am_only.gif")            save_pm = opts.get(step, {}).get("save_movie_pm_path", out_dir / "pm_only.gif")            if resume and Path(save_both).exists() and Path(save_am).exists() and Path(save_pm).exists():                results[step] = {"skipped": True, "reason": "existing movies", "dir": str(out_dir)}                continue            res = run_daily_am_pm_first_order_transitions_with_movies(                decoded_database_json=decoded_database_json,                creation_metadata_json=creation_metadata_json,                only_song_present=opts.get(step, {}).get("only_song_present", False),                restrict_to_labels=opts.get(step, {}).get("restrict_to_labels", None),                min_row_total=opts.get(step, {}).get("min_row_total", 0),                output_dir=out_dir,                save_csv=opts.get(step, {}).get("save_csv", False),                save_png=opts.get(step, {}).get("save_png", False),                show_plots=opts.get(step, {}).get("show_plots", False),                save_movie_both_path=save_both,                save_movie_am_path=save_am,                save_movie_pm_path=save_pm,                movie_fps=opts.get(step, {}).get("movie_fps", 2),                single_figsize=opts.get(step, {}).get("single_figsize", (8, 7)),                pair_figsize=opts.get(step, {}).get("pair_figsize", (14, 6)),                enforce_consistent_order=opts.get(step, {}).get("enforce_consistent_order", True),            )            results[step] = {                "dir": str(out_dir),                "movie_both": str(save_both),                "movie_am": str(save_am),                "movie_pm": str(save_pm),                "num_days": len(res),            }        else:            raise ValueError(f"Unknown step: {step}")    return results# ──────────────────────────────────────────────────────────────────────────────# Optional CLI# ──────────────────────────────────────────────────────────────────────────────if __name__ == "__main__":    import argparse    ap = argparse.ArgumentParser(description="Run AM vs PM analysis pipeline.")    ap.add_argument("decoded_database_json", type=str)    ap.add_argument("creation_metadata_json", type=str)    ap.add_argument("outdir", type=str)    ap.add_argument("--no-resume", action="store_true", help="Force re-run even if outputs exist")    ap.add_argument("--steps", nargs="*", default=[        "am_pm_syllable_heatmap",        "am_pm_transition_entropy",        "am_pm_phrase_duration",        "am_pm_transitions_movie",    ])    args = ap.parse_args()    res = run_am_pm_pipeline(        decoded_database_json=args.decoded_database_json,        creation_metadata_json=args.creation_metadata_json,        outdir=args.outdir,        steps=args.steps,        step_opts=None,        resume=not args.no_resume,    )    print("Done. Summary:")    for k, v in res.items():        print(f" - {k}: {v}")"""from wrapper_graph_AM_vs_PM_trends import run_am_pm_pipelinedecoded = "/Users/mirandahulsey-vincent/Documents/allPythonCode/syntax_analysis/data_inputs/Area_X_lesions_balanced_training_data/USA5288_decoded_database.json"meta    = "/Users/mirandahulsey-vincent/Documents/allPythonCode/syntax_analysis/data_inputs/Area_X_lesions_balanced_training_data/USA5288_creation_data.json"outdir  = "/Users/mirandahulsey-vincent/Documents/allPythonCode/syntax_analysis/py_files/figures"run_am_pm_pipeline(    decoded_database_json=decoded,    creation_metadata_json=meta,    outdir=outdir,    steps=[        "am_pm_syllable_heatmap",        "am_pm_transition_entropy",        "am_pm_phrase_duration",        "am_pm_transitions_movie",    ],    step_opts={        "am_pm_syllable_heatmap": {            "normalize": "proportion",            "log_scale": True,            "save_path": f"{outdir}/am_pm/USA5288_am_pm.png",            "show": False,        },        "am_pm_transition_entropy": {            "only_song_present": False,            "compute_durations": False,            "surgery_date_override": None,            "save_path": f"{outdir}/am_pm/USA5288_am_pm_entropy.png",            "show": False,        },        "am_pm_phrase_duration": {            "save_output_to_this_file_path": f"{outdir}/am_pm_phrase_duration",            "only_song_present": False,            "y_max_ms": 25000,            "show_plots": False,        },        "am_pm_transitions_movie": {            "output_dir": f"{outdir}/daily_transitions_am_pm",            "save_movie_both_path": f"{outdir}/daily_transitions_am_pm/am_pm_per_day.gif",            "save_movie_am_path": f"{outdir}/daily_transitions_am_pm/am_only.gif",            "save_movie_pm_path": f"{outdir}/daily_transitions_am_pm/pm_only.gif",            "movie_fps": 2,            "enforce_consistent_order": True,            "save_csv": False,            "save_png": True,            "show_plots": False,        },    },    resume=True,   # set False to force re-run)"""