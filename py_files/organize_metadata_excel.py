# organize_metadata_excel.pyfrom pathlib import Pathfrom typing import List, Optional, Union, Dict, Anyimport pandas as pddef load_metadata_with_schema(    excel_path: Union[str, Path],    *,    sheet_name: Union[str, int] = 0,    id_col: str = "Animal ID",    animal_level_cols: Optional[List[str]] = None,     # e.g. ["Treatment date", "Treatment type"]    injection_level_cols: Optional[List[str]] = None,  # e.g. ["Target region", "AP (mm)", ...]) -> Dict[str, Dict[str, Any]]:    """    Read an Excel sheet and organize it into a metadata dict per Animal ID.    Parameters    ----------    excel_path : str or Path        Path to the Excel file.    sheet_name : str or int, default 0        Sheet name or index.    id_col : str, default "Animal ID"        Column used to group rows by animal.    animal_level_cols : list[str] or None        Columns that should be stored once per animal (same for all injections).        If None, these will be inferred automatically.    injection_level_cols : list[str] or None        Columns that should be stored for each injection.        If None, these will be all remaining non-animal-level columns.    Returns    -------    metadata : dict        {          "USA5288": {              "Animal ID": "USA5288",              # animal-level fields...              "Treatment date": ...,              "Treatment type": ...,              ...              "injections": [                  {  # injection-level fields...                    "Hemisphere": "L",                    "Target region": "...",                    "AP (mm)": 5.6,                    ...                  },                  ...              ],          },          ...        }    """    excel_path = Path(excel_path)    df = pd.read_excel(excel_path, sheet_name=sheet_name)    # --- Clean up the user-specified column lists (drop missing / id_col) ---    all_cols = set(df.columns)    if animal_level_cols is not None:        animal_level_cols = [            c for c in animal_level_cols            if c in all_cols and c != id_col        ]    if injection_level_cols is not None:        injection_level_cols = [            c for c in injection_level_cols            if c in all_cols and c != id_col        ]    # --- If animal_level_cols not given, infer them as "constant per animal" ---    if animal_level_cols is None:        inferred: List[str] = []        for col in df.columns:            if col == id_col:                continue            # if every animal has only one unique value in this column,            # we'll treat it as animal-level            if df.groupby(id_col)[col].nunique(dropna=True).max() <= 1:                inferred.append(col)        animal_level_cols = inferred    # --- If injection_level_cols not given, use the remaining columns ---    if injection_level_cols is None:        injection_level_cols = [            c for c in df.columns            if c not in animal_level_cols and c != id_col        ]    metadata: Dict[str, Dict[str, Any]] = {}    for animal_id, group in df.groupby(id_col):        # animal-level: just take the first non-null value for each column        animal_entry: Dict[str, Any] = {id_col: animal_id}        for col in animal_level_cols:            vals = group[col].dropna().unique()            animal_entry[col] = vals[0] if len(vals) > 0 else None        # injection-level: one dict per row        injections = group[injection_level_cols].to_dict(orient="records")        animal_entry["injections"] = injections        metadata[str(animal_id)] = animal_entry    return metadatadef build_areax_metadata(    excel_file: Union[str, Path],    *,    sheet_name: Union[str, int] = 0,) -> Dict[str, Dict[str, Any]]:    """    Convenience wrapper for your Area X lesion metadata sheet.    Uses fixed animal-level and injection-level columns that match your schema.    In addition to the base metadata, this function adds two derived    animal-level fields per animal:        - "Medial Area X hit type"        - "Lateral Area X hit type"    Each is one of:        "bilateral"    → both L and R hemispheres have at least one hit (Y)        "unilateral_L" → only left hemisphere has hits        "unilateral_R" → only right hemisphere has hits        "miss"         → at least one explicit N, but no Y in either hemisphere        "sham"         → treatment is a bilateral saline sham injection        "unknown"      → no Y/N information available for that region    """    excel_file = Path(excel_file)    animal_level_cols = [        "Treatment date",        "Treatment type",        "centage of Area X volume lesion",  # match your exact Excel header        "Medial Area X hit?",        "Lateral Area X hit?",        "Spillover above lamina?",        "Area X visible in histology?",    ]    # IMPORTANT: include hit columns in injection_level_cols as well so each    # injection dict keeps its own per-row hit flags.    injection_level_cols = [        "Hemisphere",        "Target region",        "Head angle injection #",        "AP (mm)",        "ML (mm)",        "DV (mm)",        "Injection volume (nL)",        "Injection rate (nL/s)",        "Medial Area X hit?",        "Lateral Area X hit?",    ]    metadata = load_metadata_with_schema(        excel_file,        sheet_name=sheet_name,        id_col="Animal ID",        animal_level_cols=animal_level_cols,        injection_level_cols=injection_level_cols,    )    # ---- derive hit types (medial / lateral) for each animal ----    def _normalize_flag(val: Any) -> Optional[bool]:        """Return True/False for Y/N-like values; None if unknown/blank."""        if val is None:            return None        s = str(val).strip().upper()        if not s:            return None        if s in {"Y", "YES", "TRUE", "1"}:            return True        if s in {"N", "NO", "FALSE", "0"}:            return False        return None    def _classify_hit_type(        entry: Dict[str, Any],        *,        hit_key: str,        target_keyword: str,    ) -> str:        """        Classify hit type for one region (medial / lateral) based on per-row injection information.        Returns one of:            "bilateral", "unilateral_L", "unilateral_R", "miss", "unknown"        """        injections = entry.get("injections", []) or []        hemi_with_hit = set()  # hemispheres with at least one Y        hemi_with_any = set()  # hemispheres with any Y/N info        for inj in injections:            region = str(inj.get("Target region", "")).strip().lower()            hemi = str(inj.get("Hemisphere", "")).strip().upper()            # Be more permissive: if region doesn’t contain the target keyword,            # but still mentions "area x", we include it.            if target_keyword.lower() not in region and "area x" not in region:                continue            flag = _normalize_flag(inj.get(hit_key))            if flag is None or hemi not in {"L", "R"}:                continue            hemi_with_any.add(hemi)            if flag:                hemi_with_hit.add(hemi)        # --- classification logic ---        if not hemi_with_any:            # No explicit Y/N info for either hemisphere            return "unknown"        if not hemi_with_hit:            # We saw only N’s (no Y’s) → miss            return "miss"        if hemi_with_hit == {"L", "R"}:            return "bilateral"        if hemi_with_hit == {"L"}:            return "unilateral_L"        if hemi_with_hit == {"R"}:            return "unilateral_R"        # fallback        return "unknown"    for animal_id, entry in metadata.items():        # Check if this animal is a bilateral saline sham control        ttype = str(entry.get("Treatment type", "")).strip()        if ttype.lower() == "bilateral saline sham injection".lower():            # Negative control: explicitly label both regions as "sham"            entry["Medial Area X hit type"] = "sham"            entry["Lateral Area X hit type"] = "sham"            continue        # Otherwise classify based on Y/N flags        med_type = _classify_hit_type(            entry,            hit_key="Medial Area X hit?",            target_keyword="Medial Area X",        )        lat_type = _classify_hit_type(            entry,            hit_key="Lateral Area X hit?",            target_keyword="Lateral Area X",        )        entry["Medial Area X hit type"] = med_type        entry["Lateral Area X hit type"] = lat_type    return metadata"""Example usage:---------------from pathlib import Pathfrom pprint import pprintfrom organize_metadata_excel import build_areax_metadataexcel_file = Path("/Users/mirandahulsey-vincent/Desktop/Area_X_lesion_metadata.xlsx")metadata = build_areax_metadata(excel_file)# Inspect one animalpprint(metadata["R10"])"""